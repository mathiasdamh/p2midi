<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI</title>
</head>
<body>
    


    <script type="text/javascript">
class Song{
    constructor(name){
        this.name = name;
        this.tracks = [];
    }
    addTrack(track){
        if (tracks.indexOf(track) !== -1){
            this.tracks.push(track);
        }
        else alert("A track by that name is already in the song!");
    }
    deleteTrack(track){
        if (tracks.indexOf(track) !== -1){
            this.tracks.splice(tracks[track]);
        }
        else alert("No such track exists in this song!");
    }
}

/* ACTUAL PROGRAM */
checkMIDIAPI();
getMIDIAccess();
//createNewUser();
let activeNotes = []; //notes which have yet to be ended 
let noteArray = []; //notes which have been ended

/*GENERAL*/
function checkMIDIAPI(){
    if (navigator.requestMIDIAccess){
        console.log("This browser supports MIDIAccess");
    }
    else {
        alert("This browser does not support MIDIAccess");
    }
}

function getMIDIAccess(){
    navigator.requestMIDIAccess()
        .then(MIDIAccessSuccess, MIDIAccessFailure);
}
/* CASES SKAL ÆNDRES!!1!!1!!!!11! */
function MIDIAccessSuccess(MIDIAccessObj){
    console.log(MIDIAccessObj.inputs);
    for (let input of MIDIAccessObj.inputs.values()){
        //input.onmidimessage = sendData;
        input.onmidimessage = (message) => {
            switch (message.data[0]){
                case 144: newNote(message, activeNotes); break; //if message.data is 144, a key was pressed
                case 128: endNote(message, activeNotes, noteArray); break; // if it is 128, a key was released
                default: console.log(message.data[0]); // ??? what ???
            }
        }
    }
}

function MIDIAccessFailure(error){
    console.log(error);
}

/* CREATING A USER */

async function createNewUser(){
    let desiredName = prompt("Please enter your user name: ");
    await checkIfNameIsTaken(desiredName)
    .then(response => {
        return response.json(); // VIRKER IKKE, response er undefined, ved ikke hvorfor :(
    })
    .then(data => console.log(data));
}

async function checkIfNameIsTaken(name){
    await fetch("userCheck", {
        method: "POST",
        body: name.toLowerCase()
    });
}

function onCheckIfNameIsTakenSuccess(statusCode){ //cases skal ændres
    console.log("yoooo");
    switch (statusCode){
        case 409:
            alert("Username is already taken!");
            break;
        case 201:
            console.log("Succesfully created new user");
            break;
        default: console.log(statusCode);
    }
}

/*CREATE A NEW SONG*/

async function createNewSong(userName){
    songName = prompt("What would you like to call the song?");
    console.log("creating new track...");
    await fetch('/songs', {
        method: "PUT",
        body: JSON.stringify({user: userName, song: songName}),
        headers: {
            "Content-Type": "text"
        }
    }).then(createNewSongOnFulfilled(songName), createNewSongOnRejected);
}

function createNewSongOnFulfilled(songName){
    console.log("Succesfully created a new song with name " + songName);
}

function createNewSongOnRejected(error){
    console.log("Could not create a new song!\n\n" + error);
}

/*MAKING A TRACK*/

function newNote(message, noteArray){ // make a new note (duration will be defined in function endNote)
    let note = {
        midi: message.data[1],
        time: message.timeStamp,
        duration: undefined
    }
    activeNotes.push(note);
    console.log(activeNotes[activeNotes.length - 1]);
}

function endNote(message, activeNotes, noteArray){
    for (let i = 0; i < activeNotes.length; i++){ // loop through activeNotes
        if (message.data[1] === activeNotes[i].midi){
            activeNotes[i].duration = message.timeStamp - activeNotes[i].time;
            noteArray.push(activeNotes.splice(i, 1)[0]); // removing the ended note from activeNotes, and adding to noteArray
        }
    }
    console.log(noteArray.length);
}
/*function noteEnder(midi, noteStart){
    let result;
    console.log("in noteEnder");
    return new Promise(resolve => {
        window.addEventListener("MIDIMessageEvent", (event) => {
            if (event.data[1] === midi && event.data[0] === 128){
                console.log("terminated");
                result = event.timeStamp - noteStart;
            }
        });
        console.log("resolving");
        resolve(result);
    });
}*/
async function sendTrack(track){ // !!!NEEDS REVAMPING!!! include ID/name to the track
    console.log("sending track");
    console.log("track length: " + track.length);
    await fetch('musicData', {
        method: "POST",
        body: JSON.stringify(track),
        headers: {
            "Content-Type": "text/javascript"
        }
    }).then(sendTrackOnFulfilled(track), sendTrackOnRejected);
}

function sendTrackOnFulfilled(track){
    console.log("sent track succesfully");
    track.length = 0;
}

function sendTrackOnRejected(error){
    alert("COULD NOT SEND TRACK!!11!!1");
}

async function appendTrack(track, songInfo){ //NEEDS UPDATING - what is 'songInfo'?
    await fetch('appendTrack', {
        method: "POST",
        body: JSON.stringify({track: track, song: song})
    })
}
    </script>

</body>
</html>