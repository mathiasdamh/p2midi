<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI</title>
</head>
<body>
    


    <script type="text/javascript">
class Song{
    constructor(name){
        this.name = name;
        this.tracks = [];
    }
    addTrack(track){
        if (tracks.indexOf(track) !== -1){
            this.tracks.push(track);
        }
        else alert("A track by that name is already in the song!");
    }
    deleteTrack(track){
        if (tracks.indexOf(track) !== -1){
            this.tracks.splice(tracks[track]);
        }
        else alert("No such track exists in this song!");
    }
}


checkMIDIAPI();
getMIDIAccess();
let activeNotes = []; //notes which have yet to be ended 
let noteArray = []; //notes which have been ended


function checkMIDIAPI(){
    if (navigator.requestMIDIAccess){
        console.log("This browser supports MIDIAccess");
    }
    else {
        alert("This browser does not support MIDIAccess");
    }
}

function getMIDIAccess(){
    navigator.requestMIDIAccess()
        .then(MIDIAccessSuccess, MIDIAccessFailure);
}

function MIDIAccessSuccess(MIDIAccessObj){
    console.log(MIDIAccessObj.inputs);
    for (let input of MIDIAccessObj.inputs.values()){
        //input.onmidimessage = sendData;
        input.onmidimessage = (message) => {
            switch (message.data[0]){
                case 144: newNote(message, activeNotes); break; //if message.data is 144, a key was pressed
                case 128: endNote(message, activeNotes, noteArray); break; // if it is 128, a key was released
                default: console.log(message.data[0]); // ??? what ???
            }
        }
    }
}

function MIDIAccessFailure(error){
    console.log(error);
}

function newNote(message, noteArray){ // make a new note (duration will be defined in function endNote)
    let note = {
        midi: message.data[1],
        time: message.timeStamp,
        duration: undefined
    }
    activeNotes.push(note);
    console.log(activeNotes[activeNotes.length - 1]);
}

function endNote(message, activeNotes, noteArray){
    for (let i = 0; i < activeNotes.length; i++){ // loop through activeNotes
        if (message.data[1] === activeNotes[i].midi){
            activeNotes[i].duration = message.timeStamp - activeNotes[i].time;
            noteArray.push(activeNotes.splice(i, 1)[0]); // removing the ended note from activeNotes, and adding to noteArray
        }
    }
    console.log(noteArray.length);
}
/*function noteEnder(midi, noteStart){
    let result;
    console.log("in noteEnder");
    return new Promise(resolve => {
        window.addEventListener("MIDIMessageEvent", (event) => {
            if (event.data[1] === midi && event.data[0] === 128){
                console.log("terminated");
                result = event.timeStamp - noteStart;
            }
        });
        console.log("resolving");
        resolve(result);
    });
}*/
async function sendTrack(track){ // !!!NEEDS REVAMPING!!! for sending the track/file (undecided which) to a server 
    console.log("sending track");
    console.log("track length: " + track.length);
    await fetch('musicData', {
        method: "POST",
        body: JSON.stringify(track),
        headers: {
            "Content-Type": "text/javascript"
        }
    }).then(sendTrackOnFulfilled(track), sendTrackOnRejected);
}

function sendTrackOnFulfilled(track){
    console.log("sent track succesfully");
    track.length = 0;
}

function sendTrackOnRejected(error){
    alert("COULD NOT SEND TRACK!!11!!1");
}
    </script>

</body>
</html>